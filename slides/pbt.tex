\documentclass{beamer}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage[all]{xy}

\newcommand{\comment}[1]{\textcolor{red}{#1}}
\newcommand{\verify}[1]{\textcolor{blue}{\textbf{#1}}}
\newcommand{\falsify}[1]{\textcolor{red}{\textbf{#1}}}
% Or whatever. Note that the encoding and the font should match. If T1
% does not look nice, try deleting the line with the fontenc.

\setbeamertemplate{frametitle continuation}[from second]

% \mode<presentation>
% {
%   \usetheme{Warsaw}
%   % or ...

%   \setbeamercovered{transparent}
%   % or whatever (possibly just delete it)
% }


\title{Why property-based testing matters}

\author[Pedro Vasconcelos]{Pedro Vasconcelos \\ \texttt{pbvascon@fc.up.pt}}

\institute[LIACC, DCC/FCUP]{
  DCC/FCUP \& LIACC \\
  \includegraphics[width=0.4\textwidth]{images/fcup-identidade-logotipo-cores}
  \qquad
  \raisebox{4ex}{\includegraphics[width=0.3\textwidth]{images/liacc-logo.png}}
}


\newcommand{\bs}{\symbol{92}}

% discard trial for counter-example
\newcommand{\discard}[1]{\textcolor{red}{#1}}
\newcommand{\counter}[1]{\textbf{#1}}
\newcommand{\grayed}[1]{\textcolor{gray}{#1}}

\newcommand{\conc}{\ensuremath{\!+\!\!+}}

% If you have a file called "university-logo-filename.xxx", where xxx
% is a graphic format that can be processed by latex or pdflatex,
% resp., then you can add a logo as follows:

% \pgfdeclareimage[height=0.5cm]{university-logo}{university-logo-filename}
% \logo{\pgfuseimage{university-logo}}



% Delete this, if you do not want the table of contents to pop up atr
% the beginning of each subsection:
%\AtBeginSubsection[]
%{
%  \begin{frame}<beamer>
%    \frametitle{Overview}
%    \tableofcontents[currentsection,currentsubsection]
%  \end{frame}
%}


% If you wish to uncover everything in a step-wise fashion, uncomment
% the following command: 

%\beamerdefaultoverlayspecification{<+->}


\begin{document}

\begin{frame}
  \titlepage
\end{frame}

\begin{frame}[allowframebreaks]
  \frametitle{Overview}
  
  \begin{itemize}
  \item A long-standing challenge for software engineering 
    is ensuring software correctness
  \item Formal proofs are (still) very expensive and rarely used
  \item \emph{Tests} are the most commonly used
    practical technique 
  % \item \emph{Types} are another one (for another talk!)
  \item \emph{Unit tests} are the industry-standard
    for verification ``in the small''
  \end{itemize}

  \framebreak
  
  This talk:
  \begin{itemize}
  \item \alert{Property-based testing} as a
    automatic testing alternative to unit tests
  \item Widely available in many programming languages
  \item Many application examples in large industrial
    systems
  \item But still not commonly taught and under-utilized in practice
  \item Could validation of AI~generated code be the ``killer app''
    for PBT? 
  \end{itemize}
  
  
\end{frame}

\begin{frame}[fragile]
  \frametitle{Unit tests}
\begin{itemize}
\item Code fragments for testing functions, classes, libraries, etc.
\item Express the expected behaviour for a specific combinations of inputs
\end{itemize}
\medskip

Example: testing an integer square root function in Python.
\begin{verbatim}
def test_isqrt():
   assert isqrt(0) == 0
   assert isqrt(2) == 1
   assert isqrt(4) == 2
   assert isqrt(5) == 2
   assert isqrt(9) == 3
\end{verbatim}

\end{frame}


\begin{frame}[fragile]
  \frametitle{Problems with unit tests}

  Cognitive bias:
  \begin{itemize}
  \item how can we include an edge case in the tests
    that we didn't consider in the code?
  \end{itemize}
  \medskip
  
  Poor scaling:
  \begin{itemize}
  \item a few unit tests per feature
  \item for $n$ features, $O(n)$ unit tests
  \item but testing \emph{interactions} between features requires $O(n^2),
    O(n^3), \ldots$ unit tests
  \end{itemize}
  \pause
  \bigskip
  

    \begin{minipage}{0.6\textwidth}
      Solution:
      \medskip
      
      \begin{quote}
        ``Don't write tests \\
        --- generate them!''
      \end{quote}
      John Hughes, co-author of the \emph{QuickCheck}
      PBT library
    \end{minipage}
    \begin{minipage}{0.3\textwidth}
      \hfill
      \includegraphics[width=0.8\textwidth]{images/john-hughes}
    \end{minipage}
  
\end{frame}

\begin{frame}[allowframebreaks]
  \frametitle{Property-based testing}

\begin{itemize}
\item Write \emph{properties} instead of specific tests
\begin{itemize}
\item should be universal, i.e.\@ hold for all values
\item should define the expected behaviour for \emph{all} cases
\end{itemize}
\item Specify \emph{generators} for the inputs
\item The testings framework runs the property with
  a large number of inputs
  \begin{itemize}
  \item testing fails if a \alert{counter-example} is found
  \item otherwise, testing succeeds
  \end{itemize}
\end{itemize}

\framebreak

\begin{itemize}
\item QuickCheck (2000): first PBT library (for Haskell)
\item Implementations for other languages
  \begin{description}
    \item[PropEr] for Erlang
  \item[ScalaCheck] for Scala
  \item[Hypothesis] for Python
  \item[FsCheck] for F\#
  \end{description}
\end{itemize}

\ldots many others: \url{https://en.wikipedia.org/wiki/QuickCheck}
\end{frame}


\begin{frame}[fragile]
  \frametitle{Example property}

  What can we say about the integer square root function?
  \pause
  \medskip

  \begin{block}{Property}
    Let $r = \texttt{isqrt}(n)$; then
  $r$ should be \emph{largest non-negative integer} such that
  $r^2 \leq n$.
  \end{block}
  \pause
  \medskip

  In Python:
\begin{semiverbatim}
from hypothesis import \ldots
import hypothesis.strategies as st
@given(\alert<5>{st.integers(min_value=0)})  \only<5->{\textsl{# non-negative integer}}
def test_isqrt(\alert<4>{n}):                \only<4->{\textsl{# for all n}}
    r = isqrt(n)
    assert \alert<6>{r>=0 and r**2<=n and (r+1)**2>n}   \only<6->{\textsl{# assertion}}
  \end{semiverbatim}

\end{frame}

\begin{frame}
  \frametitle{Properties in Hypothesis}

  \begin{itemize}
  \item Properties are \emph{functions}\ldots
  \item \ldots that should fail if the expected condition is not met
  \item Arguments are \emph{universally quantified}
  \item For each property:
    \begin{itemize}
  \item generate a large number of tests (100 by default)
  \item test data is randomly generated using \emph{strategies}
  (defined in the decorator \texttt{@given})
    \end{itemize}
  \item Module \texttt{hypothesis.strategies} provides:
    \begin{itemize}
    \item \emph{predefined strategies} for basic types
    \item methods for \emph{modifying} and \emph{combining} strategies
    \end{itemize}
  \end{itemize}
\bigskip

  \hfill (Cue demo.)
\end{frame}



\begin{frame}
  \frametitle{Strategies}

  \begin{description}
  \item[integers()] generate integers
  \item[booleans()] generate logical values 
  \item[text()] generate Unicode strings
  \item[lists($s$)] lists of elements given by strategy $s$
    % \item[tuples($s1,s2,\ldots$)] lists of elements given by strategies $s1,s2,\ldots$
    \item[\ldots] many others
  \end{description}
  \bigskip
  
  We can also:
  \begin{itemize}
  \item modify strategies using \emph{parameters} (e.g.\@ \texttt{min\_value})
  \item modify strategies by \emph{mapping} and \emph{filtering}
  \item combine them using some \emph{combinator functions}
  % \item sample them using the \texttt{.example()} method    
  \end{itemize} 
\end{frame}

\begin{frame}[fragile]
  \frametitle{Generating data}

\begin{verbatim}
>>> integers().example()
848041

>>> lists(integers(min_value=0, max_value=100)).example()
[2, 29, 54, 66, 1, 27, 77, 81, 51, 18, 18]

>>> lists(integers().map(lambda x:x*2)).example()
[6668, -38, 1081651134, -6590]

>>> lists(integers()).map(sorted).example()
[-6913, -59, 37, 77, 90, 25088]

>>> lists(booleans()).filter(lambda lst:lst!=[]).example()
[False, False, True, False]
\end{verbatim}
  
\end{frame}

\begin{frame}
  \frametitle{Another example}

  Let's test the interaction between \emph{list reverse}
  and \emph{append}.
  
  Consider $x, y$ two arbitrary lists:

  \[  reverse(x + y) = \alt<1>{\hspace{2ex}???\hspace{18ex}}{reverse(y) + reverse(x)} \]
  \pause

  Example:
  \[\begin{array}{ll}
      reverse([1,2] + [3,4]) &= reverse([3,4]) + reverse([1,2]) \\
                             &= [4,3] + [2,1]\\
                             &= [4,3,2,1]
  \end{array}\] 
\end{frame}

\begin{frame}[fragile]
  \frametitle{Testing with lists of integers}

\begin{verbatim}
intlist = st.lists(st.integers())
@given(intlist, intlist)
def test_reverse_append(x, y):
    assert reverse(x + y) == reverse(x) + reverse(y)
\end{verbatim}
\medskip
\pause
  
\begin{semiverbatim}
$ pytest basic.py -k test_reverse_append

==================== FAILURES ==========================
\alert{______________ test_reverse_append _____________________}

x = [0], y = [1]
\end{semiverbatim}
What happened\ldots ?  
\end{frame}

\begin{frame}[fragile]
  \frametitle{Checking expectations}


\begin{itemize}
\item We've written the property incorrectly!
\begin{semiverbatim}
  assert reverse(x + y) == reverse(\alert{x}) + reverse(\alert{y})
      \textsf{instead of}
  assert reverse(x + y) == reverse(\alert{y}) + reverse(\alert{x})  
\end{semiverbatim}
\item Hypothesis found a counter-example:
   \[ reverse([0]+[1]) \neq reverse([0]) + reverse([1]) \]
\item Moreover: it is the \alert{smallest} counter-example
  that falsifies the property
\end{itemize}
\end{frame}

\begin{frame}[fragile,allowframebreaks]
  \frametitle{Shrinking}

Assume Hypothesis randomly generates
\begin{semiverbatim}
x = [2,2]
y = [1]
\end{semiverbatim}
This is a counter-example because:
\begin{semiverbatim}
      reverse([2,2]+[1]) \ensuremath{\neq}  reverse([2,2]) + reverse([1])
\end{semiverbatim}

To reduce ``noise'' from randomly generated data,
Hypothesis attempts to \alert{shrink the
counter example}:
\begin{itemize}
\item removing elements from the lists
\item recursively shrinking the elements inside the lists
\end{itemize}


\pagebreak

\[ \xymatrix@-0.5pc{
  & & \counter{[2,2],[1]}\ar[dll]\ar[dl]\ar[d]\ar[dr]\ar[drr]\ar@{--}[drrr] \\
  \counter{[2],[1]}\ar[d]\ar[dr]\ar[drr]\ar[drrr]\ar[drrrr] & 
  \grayed{[2],[1]} & \grayed{[0,2],[1]} & \grayed{[1,2],[1]} & 
  \grayed{[2,0],[1]} & \grayed{\cdots} \\
  \discard{[\,],[1]} & \counter{[0],[1]}\ar[dl]\ar[d]\ar[dr] &
  \grayed{[1],[1]} & \grayed{[2],[\,]} & \grayed{[2],[0]} \\
  \discard{[\,],[1]} & \discard{[0],[\,]} & \discard{[0],[0]}
} 
\]
\medskip

\begin{itemize}
\item Shrinking stops with  \texttt{x = [0]}, \texttt{y = [1]}
  (the smaller lists are no longer counter-examples)
\item For this property this is \emph{minimal} counter-example
\item In general, shrinking only finds a \emph{local minimum}
\end{itemize}
\end{frame}

\end{document}




\begin{frame}
  \frametitle{How QuickCheck works}

\begin{itemize}
\item Tests are generated using \alert{type information}
\item QuickCheck provides generators for:
\begin{itemize}
\item basic types (e.g.\@ Int);
\item common structured types (e.g.\@ lists, tuples).
\end{itemize}
\item Generation is parametrized by \alert{size}
  (try smaller values first)
\item The property is used as a test oracle
\item When the test fails, QuickCheck attempts to
  reduce \alert{shrink} the counter-example.
\item Many customizations:
\begin{itemize}
\item number of tests to generate;
\item maximum size;
\item custom generators and shrinking heuristics;
\item gathering statistical data.
\end{itemize}
\end{itemize}
\end{frame}





\begin{frame}[fragile]
\frametitle{A larger example}
\framesubtitle{Based on Erlang code from Ericsson}

SMS text packing:
\begin{itemize}
\item 7-bit characters;
\item transmitted using 8-bit \emph{bytes};
\item we can pack eight 7-bit caracteres into 7~bytes
\item two functions:
\begin{verbatim}
pack :: [Byte] -> [Byte]
unpack :: [Byte] -> [Byte]
\end{verbatim} 
\end{itemize}

\begin{block}{Left-inverse property}
\begin{verbatim}
prop_pack txt  = unpack (pack txt) == txt
\end{verbatim}
\end{block}
\end{frame}



\begin{frame}
  \frametitle{Imperative programs}

Can use QuickCheck to test programs that:
\begin{enumerate}
\item modify state;
\item read and write files;
\item use network services, databases, etc.;
\item written in other languages?
\end{enumerate}
\end{frame}

\begin{frame}
\frametitle{Testing imperative programs}

\begin{itemize}
\item Generate sequences of commands
\item Specify behaviour using a functional model
\item Compare execution against the model
\end{itemize}

\begin{center}
\includegraphics[width=0.75\textwidth]{imperative.png}
\end{center}
\end{frame}


\begin{frame}
\frametitle{Example}


A subset of the C language file API:
\begin{description}
\item [fwrite(buffer, count, stream)] write \emph{count} bytes 
  from \emph{buffer} to \emph{stream}
\item [fread(buffer, count, stream)] read \emph{count} bytes 
  from \emph{stream} to \emph{buffer}
\item [fseek(stream, offset)] set the file position for \emph{stream}
\end{description}
\end{frame}

\begin{frame}[fragile]
\frametitle{Modeling a file}

\begin{itemize}
\item A \emph{list of bytes} and an \emph{index} (position)
\item Functional model specified using standard list functions
\end{itemize}

\begin{center}
\includegraphics[width=0.7\textwidth]{split1} \\
\begin{minipage}{0.7\textwidth}
\begin{verbatim}
(prefix,suffix) = splitAt pos bytes
\end{verbatim}
\end{minipage}
\end{center}


\end{frame}


\begin{frame}[fragile]
  \frametitle{Modeling reading}


\begin{center}
\includegraphics[width=0.7\textwidth]{read1}
\end{center}

\begin{verbatim}
extract :: [Byte] -> Int -> Int -> [Byte]
extract bytes pos count
    = let (_,suffix) = splitAt pos bytes
          (out,_) = splitAt count suffix
      in out
\end{verbatim}


\end{frame}

\begin{frame}[fragile]
  \frametitle{Modeling writing}


\begin{itemize}
\item Similiar to the reading case
\item Exception: extend with zeros when writing after EOF
  (POSIX spec)
\end{itemize}
\begin{center}
\includegraphics[width=0.7\textwidth]{write1}
\end{center}

\begin{semiverbatim}
overwrite :: [Byte] -> Int -> [Byte] -> [Byte]
overwrite bytes pos new
    = let (pre, suf) = splitAt pos bytes
          (_, suf') = splitAt (length new) suf
      in \textbf{extend pre pos 0} ++ new ++ suf'
\end{semiverbatim}
\end{frame}

\begin{frame}[fragile]
\frametitle{Generating commands}

\begin{semiverbatim}
\comment{-{}- abstract syntax for commands}
data Cmd = FWrite [Byte]
         | FRead Int
         | FSeek Int

\comment{-{}- generator for commands}
\comment{-{}- choose read, write, seek with equal probability}
instance Arbitrary Cmd where
    arbitrary = oneof [liftM FWrite arbitrary,
                       liftM FRead filepos,
                       liftM FSeek filepos]

filepos :: Gen Int
filepos = sized (\bs{}n -> choose (0, min n 1000))
\end{semiverbatim}
%NB: o \emph{QuickCheck} gera \emph{sequências}
%usando o gerador dos elementos.
\end{frame}

\begin{frame}[fragile]
\frametitle{Functional model for a command}

\begin{itemize} 
\item File model is a \alert{pair}: list of bytes, position
\begin{verbatim}
type FileModel = ([Byte], Int) 
\end{verbatim}
\item First approximation: commands are \alert{transition functions}
\item But they also yield a \alert{result}:
\begin{description}
\item [\texttt{fread}:] the list of \emph{bytes} read;
\item [\texttt{fwrite}, \texttt{fseek}:]  nothing  (``void'' result)
\end{description}
\end{itemize}
\end{frame}


\begin{frame}[fragile]
  \frametitle{Modeling a command sequence}

\begin{itemize}
\item Initial state is an empty file
\item Run state transitions
\item Acumulate any read results 
\end{itemize}

\begin{description}
\item[Example] \verb|[FWrite [2,3,7], FSeek 1, FRead 2]|
\item[Results] \verb|[Nothing, Nothing, Just [3,7]]|
\end{description}

\begin{center}
\includegraphics[width=\textwidth]{state2}
\end{center}


\end{frame}


\begin{frame}[fragile]
  \frametitle{C code generation}


\begin{center}
 \texttt{[FWrite [2,3,7], FSeek 1, FRead 2]}  
\end{center}
\begin{block}{}
{\tiny
\begin{columns}[t]
\begin{column}{0.4\textwidth}
\begin{verbatim}
/* This file is an automatically 
   generated test script */
#include <stdio.h>
#define NL              printf("\n")
#define OPEN            printf("[")
#define CLOSE           printf("]")
#define COMMA           printf(",")
#define JUST            printf("Just ")
#define NOTHING         printf("Nothing")

/* global read buffer */
static unsigned char buffer[10000]; 

/* output n bytes in Haskell syntax */
void LIST(int n) { 
  int i;
  OPEN;
  if (n>0) printf("%d", (int)buffer[0]);
  for(i=1; i<n; i++) 
    printf(", %d",(int)buffer[i]);
  CLOSE;
}
\end{verbatim}
\end{column}
\begin{column}{0.5\textwidth}
\begin{verbatim}
static unsigned char data0[] = {2,3,7};

int main() {
FILE *stream = tmpfile();
OPEN;
NOTHING; fwrite(data0,1,3,stream);
COMMA;
NOTHING; fseek(stream,1,SEEK_SET);
COMMA;
JUST; LIST(fread(buffer,1,2,stream));
CLOSE;
NL;
fclose(stream);
return 0;
}
\end{verbatim}
\end{column}
\end{columns}}
\end{block}
\end{frame}



\begin{frame}[fragile]
  \frametitle{Correcteness property}

For \alert{all command sequences},  evaluating the 
functional model and the compiled C code yield the same results.
\begin{verbatim}
prop_filemodel :: [Cmd] -> Property
prop_filemodel cmds 
    = monadicIO $
      do out <- run (testScript cmds)
         assert (out == testModel cmds)
\end{verbatim}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Checking this property}

\begin{verbatim}
> quickCheck prop_filemodel 
*** Failed! (after 159 tests and 16 shrinks):    
[FSeek 1,FWrite [],FSeek 0,FRead 1]
\end{verbatim}

What went wrong?\pause
\medskip


Our functional model is incorrect: writing zero bytes should \emph{not} 
extend the file!
\end{frame}


\begin{frame}[fragile]
\frametitle{Checking again (after correcting)}

\begin{verbatim}
> quickCheck prop_filemodel
+++ OK, passed 100 tests.
\end{verbatim}

\begin{itemize}
\item Passed 100 random tests cases
\item We could pursue this further:
\begin{itemize}
\item increase the number of tests;
\item increase the test case size;
\item gather statistics.
\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Partial specifications}


\begin{itemize}
\item It is not always possible to write a full functional model
\begin{itemize}
\item can be too complex;
\item doubles the development effort (model and implementation).
\end{itemize}
\item Alternative: write properties based on partial
  specifications
\end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Observational equivalence}


$$ \texttt{[FWrite~[1,2],~FWrite~[3]]} \simeq
\texttt{[FWrite~[1,2,3]]} $$
\bigskip
\pause

\begin{block}{$cmds_1 \simeq cmds_2$}
For all contexts $C[\cdot]$,
the \alert{observable results} of executing $C[cmds_1]$ e $C[cmds_2]$
are equal.
\end{block}

\end{frame}


\begin{frame}[fragile]
  \frametitle{Observational equivalence in QuickCheck}


\begin{verbatim}
(==~) :: [Cmd] -> [Cmd] -> Property
cmds1 ==~ cmds2 
      = forAll arbitrary $ \pre ->
        forAll arbitrary $ \suf ->
        monadicIO $
        do out1<-run (obsScript (pre++cmds1++suf))
           out2<-run (obsScript (pre++cmds2++suf))
           assert (out1 == out2)
\end{verbatim}


\begin{itemize}
\item The \alert{context} is a \emph{prefix} and \emph{sufix} of commands
\item The \alert{observable result} is the sequence of bytes read
\end{itemize}


\end{frame}


\begin{frame}[fragile]
  \frametitle{Testing equivalences}

We can use the observational equivalence relation for testing:
\begin{verbatim}
> quickCheck ([FWrite [1,2],FWrite [3]] ==~ 
              [FWrite [1,2,3]])
+++ OK, passed 100 tests.

> quickCheck ([FWrite [1,2,3]]==~[FWrite [3,2,1]])
*** Failed! (after 4 tests and 3 shrinks):    
[]
[FSeek 0,FRead 1]
\end{verbatim}
The counterexample is a context that distinguishes
the left and right-hand sides.
\end{frame}

\begin{frame}[fragile]
  \frametitle{Some example properties}

\begin{semiverbatim}
\comment{-{}- sucessive writes}
prop_obsWriteSeq xs ys
    = [FWrite xs,FWrite ys] ==~ [FWrite (xs++ys)]

\comment{-{}- sucessive seeks}
prop_obsSeek 
    = forAll filepos $ \bs{}n ->
      forAll filepos $ \bs{}m -> 
      [FSeek n,FSeek m] ==~ [FSeek m]
\end{semiverbatim}
\end{frame}


\begin{frame}
  \frametitle{Industrial use example}

\begin{itemize}
\item Ericsson Media proxy
\item Establish telephony connection throught a firewall
\item Tested with Erlang QuickCheck (Quviq.com)
\item Adding and removing paricipants in a call
\item Random counterexample with 160 commands
\item Shrunk automatically to 7 commands
\end{itemize}

\begin{center}
\includegraphics[width=\textwidth]{media1}
\end{center}
\end{frame}



\begin{frame}
  \frametitle{Conclusion}

\begin{itemize}
\item QuickCheck is an \alert{domain-specific language}
  for writing \alert{properties} and \alert{generators}
  embedded in Haskell.
\item Gives a short-term pay-off for writting specifications
\item Flexible: specifications can be based on
  models, observations,  pre-and post-conditions, etc.
\item Widely used in Haskell code
\item Has been ported to many other languages
\end{itemize}
\end{frame}



\begin{frame}
  \frametitle{References}

  \begin{thebibliography}{9}
  \bibitem{QuickCheck00} Koen Claessen \& John Hughes: \newblock
    \emph{QuickCheck: A lightweight tool for random testing
      of Haskell programs}, ICFP 2000.
\bibitem{QuickCheck02} Koen Claessen \& John Hughes: \newblock
  \emph{Testing monadic code with QuickCheck}, 
  Haskell Workshop 2002.
\bibitem{telecoms} Thomas Arts, John Hughes \& Joakim Johansson: \newblock
\emph{Testing Telecoms Software with Quviq QuickCheck}, Erlang'06.
%\bibitem{Fop} Jeremy Gibbons \& Oege de Moor (editors): \newblock
%  \emph{The Fun of Programming}, Palgrave, Macmillan, 2003.
%  http://web.comlab.ox.ac.uk/oucl/publications/books/fop/
\end{thebibliography}
\end{frame}



\end{document}

